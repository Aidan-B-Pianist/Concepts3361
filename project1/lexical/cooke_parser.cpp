/*
=============================================================================
Title : cooke_parser.cpp
Description : This is a lexical parser to parse a simple cooke language
Author : Aidan Burchett R11837228
Date : 11/19/2024
Version : 1.0
Usage : Compile and run this program using the GNU C++ compiler
Notes : This is a heavily modified version of the parser.c and front.c. (I combined the two)
C++ Version : g++ (Rev2, Built by MSYS2 project) 13.2.0
=============================================================================
*/
#include <iostream>
#include <fstream>
#include <ctype.h>

#include "cooke_definitions.cpp"
#include "cooke_parser_definitions.cpp"

using namespace std;

int nextToken;
int previousToken;

static int charClass;
static char lexeme[100];
static char nextChar;
static char getPreviousChar = '\n';
static int lexLen;
static FILE *in_fp;
string tokenString;
int lineNumber = 1;
int errorCount = 0;
int boolIf = 0;
int boolElse = 0;

static void addChar();
static void getChar();
static void getNonBlank();
int lex();

static void error();

/* Parse the statements */
void parseStatements()
{

    if (nextToken == ASSIGN_OP)
    {
        if (boolIf)
        {
            error();
        }
        lex();
        expr();
        if (nextToken != SEMICOLON)
        {
            error();
        }
    }
}

/* Parse the parantheses */
void parenExpr()
{
    lex();
    expr();
    if (nextToken == CLOSE_PAREN)
    {
        lex();
    }
    else
    {
        error();
    }
    if (nextToken == ADD_OP || nextToken == SUB_OP || nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP)
    {
        lex();
        expr();
    }
}

/* Parse special parantheses */
void parseIfParens()
{
    boolElse++;
    boolIf = 1;
    lex();
    expr();
    // curl handler
    if (nextToken != CLOSE_PAREN)
    {
        error();
    }
    lex();
    boolIf = 0;
}

void parseIf()
{
    lex();
    // Parantheses handler
    if (nextToken != OPEN_PAREN)
    {
        error();
    }
    parseIfParens();
    if (nextToken != OPEN_CURL)
    {
        lex();
        error();
    }
    lex();
    /* Parse if statements continuously */
    while (nextToken != CLOSE_CURL)
    {
        expr();
        lex();
    }
    lex();
    if (nextToken == KEY_ELSE)
    {
        lex();
        if (nextToken != OPEN_CURL)
        {
            lex();
            error();
        }
        lex();
        /* Parse if statements continuously */
        while (nextToken != CLOSE_CURL)
        {
            expr();
            lex();
        }
        if (nextToken != CLOSE_CURL)
        {
            error();
        }
    }
    expr();
}

void parseElse()
{
    lex();
    if (nextToken != OPEN_CURL)
    {
        error();
    }
    lex();
    /* Parse if statements continuously */
    while (nextToken != CLOSE_CURL)
    {
        expr();
        lex();
    }
    if (nextToken != CLOSE_CURL)
    {
        error();
    }
    boolElse--;
}

void expr()
{
    // cout << "Enter <expr>" << endl;
    /* Parse the first term */

    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP)
    {
        lex();
        term();
    }

    // cout << "Exit <expr>" << endl;
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term()
{
    // cout << "Enter <term>" << endl;
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == EQUAL_OP || nextToken == GREATER_OP || nextToken == BOOL_AND || nextToken == NEQUAL_OP || nextToken == GEQUAL_OP || nextToken == LEQUAL_OP || nextToken == LESSER_OP || nextToken == BOOL_OR || nextToken == MOD_OP)
    // while(nextToken == MULT_OP || nextToken == DIV_OP)
    {
        lex();
        factor();
    }
    // cout << "Exit <term>" << endl;
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor()
{
    // cout << "Enter <factor>" << endl;
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT)
    {
        lex();
        if (nextToken == ASSIGN_OP)
        {
            parseStatements();
        }
    }
    else
    {
        /* If the RHS is (<expr>), call lex to pass over the
        left parenthesis, call expr, and check for the right
        parenthesis */

        switch (nextToken)
        {
        case KEY_IF:
            parseIf();
            break;
        case KEY_OUT:
            lex();

            // Handle parantheses
            if (nextToken == OPEN_PAREN)
            {
                lex();
                expr();
                if (nextToken == CLOSE_PAREN)
                {
                    lex();
                    if (nextToken != SEMICOLON)
                    {
                        error();
                    }
                }
            }
            else
            {
                error();
            }
            break;

        case KEY_IN:
            lex();

            // Handle parantheses
            if (nextToken == OPEN_PAREN)
            {
                lex();
                expr();
                if (nextToken == CLOSE_PAREN)
                {
                    lex();
                    if (nextToken != SEMICOLON)
                    {
                        error();
                    }
                }
            }
            else
            {
                error();
            }
            break;
        case OPEN_PAREN:
            parenExpr();
            break;
        default:
            break;
        }

        if (nextToken == EOF)
        {
            if (errorCount == 0)
            {
                cout << "Syntax Validated" << endl;
            }
        }
        else if (nextToken == SEMICOLON)
        {
        }
        else if (nextToken == CLOSE_CURL)
        {
        }
        else if (nextToken == KEY_ELSE)
        {
        }
        else if (nextToken == CLOSE_PAREN)
        {
        }
        /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else
        {
            error();
        }
    } /* End of else */
    // cout << "Exit <factor>" << endl;

} /* End of function factor */

static void error()
{
    cout << "Error Encounter on line " << lineNumber << ": The next lexeme was " << lexeme << " and the next token was " << tokenString << endl;
    exit(1);
}

static void getChar()
{

    if ((nextChar = getc(in_fp)) != EOF)
    {

        if (isalpha(nextChar))
            charClass = LETTER;
        else if (isdigit(nextChar))
            charClass = DIGIT;
        else
            charClass = UNKNOWN;
    }
    else
    {
        charClass = EOF;
    }
}

static void getNonBlank()
{
    while (isspace(nextChar))
    {
        if (nextChar == '\n')
        {
            lineNumber++;
        }
        getChar();
    }
}

static void addChar()
{
    if (lexLen <= 98)
    {
        lexeme[lexLen++] = nextChar;
        lexeme[lexLen] = 0;
    }
    else
    {
        printf("Error - lexeme is too long \n");
    }
}

/* Get the string value of each token*/
string valueOf(int token)
{
    switch (token)
    {
    case 0:
        return "LETTER";
        break;

    case 1:
        return "DIGIT";
        break;

    case 99:
        return "UNKNOWN";
        break;

    case 10:
        return "ASSIGN_OP";
        break;

    case 11:
        return "LESSER_OP";
        break;

    case 12:
        return "GREATER_OP";
        break;

    case 13:
        return "EQUAL_OP";
        break;

    case 14:
        return "NEQUAL_OP";
        break;

    case 15:
        return "LEQUAL_OP";
        break;

    case 16:
        return "GEQUAL_OP";
        break;

    case 17:
        return "OPEN_PAREN";
        break;

    case 18:
        return "CLOSE_PAREN";
        break;

    case 19:
        return "ADD_OP";
        break;

    case 20:
        return "SUB_OP";
        break;

    case 21:
        return "MULT_OP";
        break;

    case 22:
        return "DIV_OP";
        break;

    case 23:
        return "MOD_OP";
        break;

    case 24:
        return "BOOL_AND";
        break;

    case 25:
        return "BOOL_OR";
        break;

    case 26:
        return "BOOL_NOT";
        break;

    case 27:
        return "SEMICOLON";
        break;

    case 28:
        return "KEY_IN";
        break;

    case 29:
        return "KEY_OUT";
        break;

    case 30:
        return "KEY_IF";
        break;

    case 31:
        return "KEY_ELSE";
        break;

    case 32:
        return "OPEN_CURL";
        break;

    case 33:
        return "CLOSE_CURL";
        break;

    case 34:
        return "INT_LIT";
        break;

    case 35:
        return "IDENT";
        break;

    default:
        return "";
        break;
    }
}

/* look up operators and parantheses*/
static int lookup(char ch)
{
    switch (ch)
    {
    case '=':
        addChar();
        getChar();
        if (nextChar == '=')
        {
            addChar();
            nextToken = EQUAL_OP;
        }
        else
        {
            nextToken = ASSIGN_OP;
            return nextToken;
        }
        break;
    case '!':
        addChar();
        getChar();
        if (nextChar == '=')
        {
            addChar();
            nextToken = NEQUAL_OP;
        }
        else
        {
            nextToken = BOOL_NOT;
            return nextToken;
        }
        break;
    case '<':
        addChar();
        getChar();
        if (nextChar == '=')
        {
            addChar();
            nextToken = LEQUAL_OP;
        }
        else
        {
            nextToken = LESSER_OP;
            return nextToken;
        }
        break;
    case '>':
        addChar();
        getChar();
        if (nextChar == '=')
        {
            addChar();
            nextToken = GEQUAL_OP;
        }
        else
        {
            nextToken = GREATER_OP;
            return nextToken;
        }
        break;
    case '(':
        addChar();
        nextToken = OPEN_PAREN;
        break;
    case ')':
        addChar();
        nextToken = CLOSE_PAREN;
        break;
    case '+':
        addChar();
        nextToken = ADD_OP;
        break;
    case '-':
        addChar();
        nextToken = SUB_OP;
        break;
    case '*':
        addChar();
        nextToken = MULT_OP;
        break;
    case '/':
        addChar();
        nextToken = DIV_OP;
        break;
    case ';':
        addChar();
        nextToken = SEMICOLON;
        break;
    case '{':
        addChar();
        nextToken = OPEN_CURL;
        break;
    case '}':
        addChar();
        nextToken = CLOSE_CURL;
        break;
    case '&':
        addChar();
        getChar();
        if (nextChar == '&')
        {
            addChar();
            nextToken = BOOL_AND;
        }
        else
        {
            nextToken = UNKNOWN;
        }
        break;
    case '|':
        addChar();
        getChar();
        if (nextChar == '|')
        {
            addChar();
            nextToken = BOOL_OR;
        }
        else
        {
            nextToken = UNKNOWN;
        }
        break;
    case '%':
        addChar();
        nextToken = MOD_OP;
        break;
    default:
        addChar();
        nextToken = UNKNOWN;
        break;
    }
    getChar();
    return nextToken;
}

int lex()
{
    lexLen = 0;
    getNonBlank();
    getPreviousChar = nextChar;
    string str = "";
    switch (charClass)
    {
    /* Parse identifiers */
    case LETTER:
        addChar();
        getChar();
        while (charClass == LETTER || charClass == DIGIT)
        {
            addChar();
            getChar();
        }
        str = lexeme;
        if (!str.compare("input"))
        {
            nextToken = KEY_IN;
        }
        else if (!str.compare("output"))
        {
            nextToken = KEY_OUT;
        }
        else if (!str.compare("if"))
        {
            nextToken = KEY_IF;
        }
        else if (!str.compare("else"))
        {
            nextToken = KEY_ELSE;
        }
        else
        {
            nextToken = IDENT;
        }
        str = "";
        break;

    /* Parse integer literals */
    case DIGIT:
        addChar();
        getChar();
        while (charClass == DIGIT)
        {
            addChar();
            getChar();
        }
        nextToken = INT_LIT;
        break;

    /* Parentheses and operators */
    case UNKNOWN:
        lookup(nextChar);
        break;

    /* EOF */
    case EOF:
        if (nextToken == CLOSE_CURL || nextToken == SEMICOLON)
        {
            previousToken = nextToken;
            nextToken = EOF;
            lexeme[0] = 'E';
            lexeme[1] = 'O';
            lexeme[2] = 'F';
            lexeme[3] = 0;
        }
        else
        {
            error();
        }
        break;

    } /* End of switch */
    tokenString = valueOf(nextToken);

    return nextToken;
} /* End of function lex */

int main(int argc, char *argv[])
{

    if (argc > 1)
    {
        in_fp = fopen(argv[1], "r");
    }
    else
    {
        cout << "Error: No File" << endl;
        exit(2);
    }
    if (in_fp == NULL)
    {
        cout << "Error: No Data in File" << endl;
        exit(3);
    }

    for (int i = 0; i < argc; i++)
    {
        cout << argv[i];
    }
    cout << endl;

    if (in_fp == NULL)
    {
        cout << "ERROR - cannot open file \n"
             << endl;
    }
    else
    {
        cout << "Cooke Parser :: R11837228\n"
             << endl;
        getChar();
        do
        {
            lex();
            expr();
        } while (nextToken != EOF);
    }
    return 0;
}